Redis 的持久化机制有哪些？

Redis 有 RDB 和 AOF 两种持久化机制：

- **RDB**：定期把 Redis 内存数据保存到磁盘，防止异常退出或断电等情况导致数据丢失。

- 优点是快照文件小、恢复速度快，适合备份和灾难恢复；
- 缺点是定期更新可能造成数据丢失。

- **AOF**：把所有写操作追加到 AOF 文件末尾，记录运行期间所有修改操作，重启时依此恢复数据。

- 优点是数据可靠性更高、能实现更细粒度的数据恢复，适合数据存档和备份；
- 缺点是文件大占空间多，每次写操作都要写磁盘，负载较高 。

**两者的对比**

| **特性** | **RDB**          | **AOF**            |
| ------ | ---------------- | ------------------ |
| 数据可靠性  | 可能会丢失最后一次快照之后的数据 | 保证最后一次写操作之前的数据不会丢失 |
| 性能     | 读写性能较高，适合做数据恢复   | 写性能较高，适合做数据存档      |
| 存储空间占用 | 快照文件较小，占用空间较少    | AOF文件较大，占用空间较多     |
| 恢复时间   | 从快照文件中恢复数据较快     | 从AOF文件中恢复数据较慢      |

**混合持久化**

- Redis 4.0 推出 RDB - AOF 混合持久化，融合 AOF 和 RDB 优点。
- 开启混合持久化时，**AOF 重写**把持久化数据以 RDB 格式写在 AOF 文件开头，后续以 AOF 格式追加。
- 通过 `aof-use-rdb-preamble` 参数开启混合模式。
- 优点：开头 RDB 格式使 Redis 启动更快，结合 AOF 降低数据丢失风险。
- 缺点：AOF 文件中加入 RDB 格式致可读性差，且混合持久化 AOF 文件不向下兼容旧版本

### 扩展知识

#### RDB和AOF详解

**写回策略**是指将数据从内存写入到持久化存储（如磁盘）的方式和时机。在Redis中，不同的持久化机制有着不同的写回策略。

#### RDB

**写回策略**

在Redis中，RDB的写回策略主要包括以下几个方面：

- **定期触发**

- Redis 通过配置文件中的 `save` 参数定义 RDB 自动保存条件，默认配置示例如下：

- `save 900 1`：900 秒内至少 1 个键变化则保存快照。
- `save 300 10`：300 秒内至少 10 个键变化则保存快照。
- `save 60 10000`：60 秒内至少 10000 个键变化则保存快照。

策略方面，Redis 定期检查条件，满足即触发 RDB 保存操作，条件可通过修改 `redis.conf` 文件自定义，也能用命令动态设置，如 `CONFIG SET save "300 10 60 10000"`。

- **手动触发**

- RDB 文件生成的命令有：

- `SAVE`：阻塞 Redis 服务器直至快照完成，不适合生产环境。
- `BGSAVE`：在后台异步生成 RDB 文件，不阻塞 Redis，通过 fork 子进程生成快照，较高效但需一定系统资源 。
- lastsave 命令可以获取最后一次成功执行快照的时间

SAVE 操作直接在主线程完成，不适合生产环境。BGSAVE 会 fork 一个子进程生成快照，更高效，但需要一定的系统资源（如内存和CPU）。

**但是对于Redis7版本和以往版本的RDB的配置有一些区别的：**

**Redis7之前：**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736157217262-f5b892df-aff8-45d8-ad68-d5d19ca4b72e.png)

**Redis7：**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736157240143-db127393-197e-4728-b735-5551d33a84bd.png)

**持久化工作流程（bgsave）**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736157554560-b63300bd-5107-4940-9fe2-e3547a133285.png)

1. 检查是否存在正在进行 AOF 或 RDB 操作的子进程，若存在则返回错误。
2. 触发持久化，调用 `rdbSaveBackground` 函数。
3. 开始 `fork` 操作，生成的子进程执行 RDB 操作，而主进程继续响应其他操作。
4. 子进程完成 RDB 操作后，用新生成的 RDB 文件替换旧文件，然后子进程退出 。

#### AOF

**写回策略**

AOF 有三种写回策略决定数据同步到磁盘的时机：

- **always**：每次写操作后立即调用 fsync 将数据同步到磁盘，数据安全性最高，性能显著降低。
- **everysec**：每秒调用一次 fsync 同步数据到磁盘，在性能和数据安全性间折中，为默认策略，最多丢失 1 秒数据。
- **no**：由操作系统决定何时将数据写入磁盘，性能最高，数据安全性较低，Redis 崩溃时可能丢失较多数据。

“同步写回” 可靠性最高，每写命令后同步落盘，但与直接写磁盘数据库类似，可能影响性能。“操作系统控制的写回” 可靠性差，无法预知操作系统持久化时机，宕机易丢失数据。“每秒写回” 是折中方案，异步每秒写回磁盘，兼顾效率与风险 。

**持久化工作流程**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736160393743-4ccb426c-9dc2-45c4-b092-37b3f51c122d.png)

#### AOF重写机制

AOF 文件随写操作增加而变大，过大时会影响恢复速度并占用大量磁盘空间，Redis 因此提供 AOF 重写机制对其压缩，通过最少命令生成等效 AOF 文件。**重写并非修改现有文件，而是生成新文件**。

拿 key A 举个例子，AOF 记录了每次写命令如 set A 1、set A 2、set A 3。实际上前面的 set A 1、set A 2 是历史值，我们仅关心最新的值，因此 AOF 重写就是仅记录数据的最终值即可，即set A 3，这样 AOF 文件就“瘦身”了。

**流程如下**：

- 使用 BGREWRITEAOF 命令创建子进程负责重写。
- 子进程依数据库状态将键的最新值转写命令写入新 AOF 文件。
- 重写中主进程处理新写操作，同时将新命令追加到现有 AOF 文件和缓冲区。
- 子进程完成后，主进程将缓冲区新命令追加到新 AOF 文件。
- 最后用新文件替换旧文件完成重写。

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736161493690-6ddb09bb-2af9-48a1-b7ce-beb64009eecb.png)

AOF 重写有手动触发和自动触发两种方式：

- **手动触发**：使用 BGREWRITEAOF 命令。
- **自动触发**：通过配置文件参数控制。其中，auto-aof-rewrite-min-size 规定 AOF 文件达到一定大小（默认 64 MB）时允许重写；auto-aof-rewrite-percentage 表示当前 AOF 文件大小相对上次重写后的增长百分比达到设定值时触发重写。

#### Redis 7.0 MP-AOF（Multi-Part Append Only File）

**7.0 之前 AOF 重写问题**

- **内存开销**：aof_buf 和 aof_rewrite_buf 存在大量重复内容。
- **CPU 开销**：主进程需花时间向 aof_rewrite_buf 写入及向子进程发送数据，子进程要消耗时间将其写入新 AOF 文件。
- **磁盘开销**：aof_buf 和 aof_rewrite_buf 数据分别写入当前和新 AOF 文件，同一份数据需写两次磁盘

针对以上问题 Redis 7.0 引入了 MP-AOF（Multi-Part Append Only File）机制。简单来说就是将一个 AOF 文件拆分成了多个文件：

- 一个基础文件（base file），代表数据的初始快照
- 增量文件（incremental files），记录自基础文件创建以来的所有写操作，可以有多个
- 基础文件和增量文件都会存放在一个单独的目录中，并由一个清单文件（manifest file）进行统一跟踪和管理

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736161811832-3da30b45-6e44-443b-9764-cb11f5c9e4c2.png)

**大致流程如下：**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736161985376-b0879ef5-0307-403b-b72d-4f9d4ea3e486.png)

Redis 7.0 的 MP-AOF 机制在 AOF 重写方面有显著改进：

- **数据写入优化**：重写期间数据变更直接写入 aof_buf 再到新的增量 AOF 文件，避免之前多个缓冲区的重复写入。
- **节省 CPU 开销**：子进程独立重写基础 AOF 文件，与主进程无交互，节省主进程 CPU 资源。
- **重写结束操作**：重写完成后，只需更新 manifest 文件，加入新的增量和基础 AOF 文件，将旧文件标记为历史文件（异步删除），更新 manifest 即标志 AOF 重写结束 。

#### AOF文件修复

如果 AOF 文件因系统崩溃等原因损坏，可以使用 `redis-check-aof` 工具修复。该工具会截断文件中的不完整命令，使其恢复到一致状态。

## Redis 主从复制的实现原理是什么？

### 总结分析

Redis 的主从复制指一个主节点可将数据复制到一个或多个从节点，从节点与主节点保持数据同步，其流程如下：

- 开始同步：从节点向主节点发送 PSYNC 命令发起同步请求。
- 全量复制：首次连接或连接失效时，从节点请求全量复制，主节点发送当前数据快照（RDB 文件）。
- 增量复制：全量复制完成后，主从保持长连接，主节点通过该连接将后续写操作传给从节点以保证数据一致。

### 扩展分析

#### 主从架构

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736163209130-a299b2ce-457e-45ce-b876-94152172aca1.png)  
  

#### 主从复制步骤

总的来说主从复制功能的详细步骤可以分为7个步骤：

1. 设置主节点的地址和端口
2. 建立套接字连接
3. 发送PING命令
4. 权限验证
5. 同步
6. 命令传播

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736163495225-1800aeec-7ac9-4539-9061-3776f7372675.png)

接下来进行逐步分析：

#### 1. 设置主服务器的地址和端口

- **开启方式**：主从复制由从节点发起，主节点无需操作。从节点开启主从复制有三种等效方式：

- **配置文件**：在从服务器配置文件中加入`slaveof masterip masterport`。
- **启动命令**：`redis-server`启动命令后加入`--slaveof masterip masterport`。
- **客户端命令**：Redis 服务器启动后，通过客户端执行`slaveof masterip masterport`，该实例即成为从节点。

- **后续操作**：完成配置后，从服务器会将主服务器的 IP 地址和端口号保存到服务器状态属性中，可使用`info Replication`命令分别查看从服务器和主服务器的主从信息。

#### 2.建立套接字连接

当在从服务器执行`slaveof`命令后，从服务器会依据所设置的 IP 和端口向主服务器建立 socket 连接。例如在 6380 从服务器执行`slave of 127.0.0.1 6379`，即表示从服务器向主服务器发起 socket 连接。此时执行`info Replication`命令， 6380 服务器的角色已变为`slave`。这表明从服务器已成功开启主从复制流程中的连接建立步骤，为后续的数据同步等操作做好了准备。

#### 3.发送Ping命令

从节点成为主节点的客户端后，会发送 ping 命令进行首次请求，目的是检查 socket 连接可用性以及主节点能否处理请求。发送 ping 命令后可能出现以下 3 种情况：

1. **返回 pong**：表明 socket 连接正常，主节点可处理请求，复制过程继续。
2. **超时**：一定时间内未收到主节点回复，意味着 socket 连接不可用，从节点断开连接并重连。
3. **返回 pong 以外的结果**：若主节点返回其他结果，说明主节点当前无法处理命令，从节点断开连接并重连 。

#### ![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736164819974-2e33d179-55fa-4993-ac84-b8695a567a74.png)

#### 4.身份验证

- 从节点的`masterauth`选项决定是否向主节点进行身份验证，设置了该选项就需要，未设置则不需要。
- 从节点通过发送`auth`命令进行身份验证，命令参数是配置文件中`masterauth`的值。
- 主节点设置密码的状态与从节点`masterauth`状态一致时（都存在且密码相同，或都不存在），身份验证通过，复制继续；不一致则从节点断开`socket`连接并重连。

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736165049876-c29f9457-6ac9-4a6c-8f0c-0bfba5a6267a.png)

#### 5.同步

- 同步是使从节点数据库状态与主节点当前状态一致，从节点发送`psync`命令（Redis2.8 前是`sync`命令）开启同步。
- 数据同步阶段是主从复制关键部分，根据主从节点状态不同分为**全量复制**和**部分复制**，后续会详细介绍。

#### 6.命令传播

- 主从同步后状态会因主节点新写命令而不一致，之后进入命令传播阶段，主节点发写命令给从节点执行来保证一致性。
- 命令传播异步，主从难实时一致，延迟难免，其程度与网络、写命令频率、repl-disable-tcp-nodelay 配置等有关。
- repl-disable-tcp-nodelay

- 假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟，造成master与slave数据不一致
- 假如设置成no，则redis master会立即发送同步数据，没有延迟
- 概括来说就是：前者关注性能，后者关注一致性

**Redis是如何保证主从服务器一致处于连接状态以及命令是否丢失？**  
命令传播阶段，从服务器会利用**心跳检测机制**定时的向主服务发送消息。

### 全量复制和部分复制

- **Redis 2.8 以前**，从节点用 sync 命令请求同步，同步方式是全量复制。
- **Redis 2.8 及以后**，从节点用 psync 命令请求同步，同步方式根据主从节点状态可能是全量复制或部分复制，后文以该版本及以后为例。

- **全量复制**：用于初次复制或无法进行部分复制的情况，主节点将所有数据发送给从节点，操作重型。
- **部分复制**：用于网络中断等情况后的复制，只发送中断期间主节点的写命令，更高效；但网络中断时间过长，主节点未完整保存中断期间写命令时，无法进行部分复制，仍用全量复制 。

#### 全量复制

- **发起请求**：从节点判断无法部分复制而请求全量复制，或从节点请求部分复制但主节点判定无法进行，具体判断后续介绍。
- **生成文件与记录命令**：主节点接收到全量复制命令后，执行 bgsave 后台生成 RDB 文件，同时用复制缓冲区记录新写命令。
- **传输与更新数据**：主节点 bgsave 完成后发送 RDB 文件给从节点，从节点清除旧数据、载入文件，将数据库状态更新至主节点执行 bgsave 时的状态。
- **更新至最新状态**：主节点把复制缓冲区的写命令发送给从节点执行，使从节点数据库状态更新至主节点最新状态。
- **更新 AOF 文件（若开启）**：若从节点开启 AOF，会触发 bgrewriteaof，确保 AOF 文件更新至主节点最新状态 。

流程图如下：

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736165901779-5c6694b7-2779-4839-b13d-e74d5a115aa6.png)

**存在问题**：

- **主节点 RDB 持久化开销大**：主节点执行`bgsave`命令 fork 子进程进行 RDB 持久化，此过程对 CPU、内存（页表复制）以及硬盘 IO 消耗较大。
- **网络带宽消耗大**：主节点需通过网络将 RDB 文件发送给从节点，这会大量消耗主从节点的带宽。
- **从节点操作影响服务**：从节点清空老数据、载入新 RDB 文件的过程会阻塞，无法响应客户端命令，若执行`bgrewriteaof`还会带来额外消耗。

#### 部分复制

由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。

部分复制的实现，依赖于三个重要的概念：

1. 复制偏移量
2. 复制积压缓冲区
3. 服务器运行ID(runid)  
    下面我们分别讲解一下这三个概念。

#### 复制偏移量

- 主从节点在执行复制时，各自维护一个复制偏移量`offset`。
- 主节点向从节点同步`N`字节数据后，自身`offset`增加`N`；从节点从主节点同步`N`字节数据后，自身`offset`也增加`N`。
- `offset`可用于判断主从节点数据库状态一致性：若两者`offset`相同，状态一致；若不同则不一致。
- 当`offset`不同时，能依据两个`offset`确定从节点缺少的数据部分，如主节点`offset`为 1000，从节点`offset`为 500，部分复制需传递`offset`为 501 - 1000 的数据，这部分数据存储在复制积压缓冲区。

#### 复制积压缓冲区（repl_backlog_buffer）

- 主节点维护一个默认大小为 1MB 的固定长度、先进先出（FIFO）队列作为复制积压缓冲区。
- 主节点在命令传播时，既向从节点同步写命令，也将写命令写入复制积压缓冲区，该缓冲区保存主节点最近执行的写命令，较早的命令会被挤出。
- 若主从节点 offset 差距过大超过缓冲区长度，无法执行部分复制，只能进行全量复制。
- 可通过配置 `repl-backlog-size` 增大复制积压缓冲区大小来提高网络中断时部分复制执行的概率，例如根据网络中断平均时间和主节点每秒产生写命令字节数计算出缓冲区需求，适当增大以保证多数断线情况可用部分复制。
- 从节点向主节点发送 offset 后，主节点依据 offset 和缓冲区大小决定复制方式：若 offset 偏移量之后的数据仍在缓冲区，则执行部分复制；若不在（已被挤出），则执行全量复制。

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736167075207-8afb0aee-44f5-4394-977f-4668843d45b2.png)

#### 服务器运行id（runid）

- 每个 Redis 节点都有在启动时自动生成的运行 ID。主节点会将自身运行 ID 发送给从节点，从节点保存该运行 ID。
- 从节点断开重连时，依据运行 ID 判断同步进度：

- 若从节点保存的 runid 与主节点当前 runid 相同，表明主从节点此前同步过，主节点会尝试进行部分复制（最终能否部分复制取决于 offset 和复制积压缓冲区情况）。
- 若从节点保存的 runid 与主节点当前 runid 不同，意味着从节点断线前同步的并非当前主节点，此时只能进行全量复制 。

**执行流程如下：**

![](https://cdn.nlark.com/yuque/0/2025/png/26566882/1736166711012-2b0d5f33-4651-43ec-9063-17f86ae58cbd.png)

**主节点收到psync命令后，会出现以下三种可能：**

- 主节点返回 fullresync {runid} {offset}回复，表示主节点要求与从节点进行数据的完整全量复制，其中runid表示主节点的运行ID，offset表示当前主节点的复制偏移量
- 如果主服务器返回 +continue，表示主节点与从节点会进行部分数据的同步操作，将从服务器缺失的数据复制过来即可
- 如果主服务器返回 -err，表示主服务器的Redis版本低于2.8，无法识别psync命令，此时从服务器会向主服务器发送sync命令，进行完整的数据全量复制

#### 心跳检测机制

**心跳检测机制有以下三个作用：**

- **检查网络连接状态**：主节点信息中可查看从节点连接信息，包括状态、复制偏移量、延迟值（几秒前有过心跳检测）等，以此检查主从服务器网络连接状态。
- **辅助实现 min-slaves 选项**：Redis.conf 配置文件中有`min-slaves-to-write`（最少包含的从服务器数量）和`min-slaves-max-lag`（延迟值）两个参数，若取消注释，当从服务器数量少于 3 个或三个从服务器延迟大于等于 10 秒时，主服务器会拒绝执行写命令。

```
# 未达到下面两个条件时，写操作就不会被执行
# 最少包含的从服务器
# min-slaves-to-write 3
# 延迟值
# min-slaves-max-lag 10
```

- **检测命令丢失**：从服务器连接信息中有复制偏移量，若主从服务器复制偏移量不一致，主服务器会补发缺失数据。

## Redis 数据过期后的删除策略是什么？

### 总结分析

Redis 数据过期有两种删除策略：

- **定期删除**：Redis 每隔约 100 毫秒随机检查一定数量键，若发现过期键则删除，可在后台持续清理过期数据，防止内存膨胀。
- **惰性删除**：每次访问键时，Redis 检查其是否过期，若过期则删除，此策略确保使用时只删不再需的数据，不访问过期键时不立即清除。

### 扩展分析

#### 定期删除

- **基本原理**：Redis 内部定时任务，每 100ms 周期性扫描设置过期时间的键。
- **扫描限制**：不会一次性扫描所有，每次扫描限制时间和数量，每次取 20 个 key 判断是否过期，过期 key 占比超 25% 则再取 20 个，小于 25% 或一次删除时间超 25ms 则停止，防止过度消耗 CPU 资源，可能导致部分过期键未及时删除。

#### 惰性删除

- **优点**：减少 CPU 占用，仅在查询相关数据时执行删除操作，无需定时主动删除。
- **缺点**：若一直未查询某 Key，可能不被删除，易造成内存泄漏。

#### 内存回收机制

- **触发条件**：Redis 内存使用达 maxmemory 限制时触发。
- **删除策略**：

- volatile-lru：从设置过期时间的键中用 LRU 算法删除。
- allkeys-lru：从所有键中用 LRU 算法删除。
- volatile-lfu：从设置过期时间的键中用 LFU 算法删除。
- allkeys-lfu：从所有键中用 LFU 算法删除。
- volatile-random：从设置过期时间的键中随机删除。
- allkeys-random：从所有键中随机删除。
- volatile-ttl：从设置过期时间的键中根据 TTL 优先删除存活时间短的键。
- noeviction：不删除键，拒绝写入新数据。

Redis 正常情况下使用惰性删除 + 定期删除处理过期键，内存回收机制属于异常时的兜底处理。

#### Redis 键过期时间设置

- EXPIRE：以秒为单位设置键的过期时间。
- PEXPIRE：以毫秒为单位设置键的过期时间。
- SETEX：设置键值同时定义过期时间（秒级）。
- PSETEX：类似 SETEX，支持毫秒级过期时间。

之前看到过一篇阿里的文章，感觉结合实际场景更能深入了解和记忆

[从一个事故中理解Redis（几乎）所有知识点](https://mp.weixin.qq.com/s/v_Wnrvf25UyKzRgvDziMeA)