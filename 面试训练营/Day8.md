## MySQL中如果发生死锁应该如何解决？

## 总结分析

### 什么是死锁？

### 死锁概述

死锁指两个或多个进程（或线程）执行中，因资源竞争或通信而阻塞，无外力则无法推进，处于此状态的系统中，相互等待的进程即死锁进程。

#### 死锁产生的必要条件

1. **互斥条件**：资源每次仅能被一个进程使用。
2. **占有且等待**：进程请求资源受阻时，不释放已获取的资源。
3. **不可强行占有**：进程已获资源在未使用完前，不能被强行剥夺。
4. **循环等待条件**：进程间形成循环等待资源的关系。

#### 死锁的解除与预防

避免四个必要条件同时发生可解除和预防死锁，常见方法包括：

- **破坏不可抢占**：设置优先级，让高优先级进程能抢占资源。
- **破坏循环等待**：确保多个进程（线程）执行顺序相同，防止循环等待资源情况出现。

### 数据库死锁相关总结

#### 一、死锁产生原因

1. 资源竞争：多个事务对相同资源（如数据库表、行等）请求顺序不同引发互相等待。
2. 未释放资源：事务完成后未释放资源，常因程序错误或异常所致。
3. 事务执行速度差异：获取资源后执行慢的事务使其他事务等待超时。
4. 操作数据量过大：持有锁时又请求更多锁致互相等待。

#### 二、死锁解决办法

1. 自动干预：多数现代数据库管理系统检测到死锁会自动回滚部分事务打破死锁。
2. 手动强制回滚：部分 DBMS 支持手动操作，如 Navicat 可按特定步骤关闭死锁进程。
3. MySQL 自身处理：开启死锁检测（innodb_deadlock_detect = on）可定时检测并自动终止事务解决；设置事务等待锁超时时间（innodb_lock_wait_timeout），超时则回滚事务解决。

#### 三、避免死锁方法

1. 减少锁数量：用 RC 替代 RR 规避因 gap 锁和 next - key 锁引发的死锁。
2. 减少锁时长：加快事务执行速度、缩短执行时间。
3. 固定顺序访问数据：事务访问同表时按相同顺序获取锁。
4. 减少操作数据量：降低事务操作数据规模及持有时间。

### 死锁示例图

![](https://cdn.nlark.com/yuque/0/2024/png/26566882/1735648685529-e2a0cd31-993d-4c9c-8025-4df0dfd38323.png)

### 如何解决死锁?

1. **自动干预**：多数现代数据库管理系统检测到死锁会自动回滚部分事务打破死锁。
2. **手动强制回滚**：部分 DBMS 支持手动操作，如 Navicat 可按特定步骤关闭死锁进程。
3. **MySQL 自身处理**：开启死锁检测（innodb_deadlock_detect = on）可定时检测并自动终止事务解决；设置事务等待锁超时时间（innodb_lock_wait_timeout），超时则回滚事务解决。

### 如何避免死锁？

常见避免或降低死锁的手段如下：

- **事务处理方面**：避免大事务，将其拆分为多个小事务以快速释放锁，减少锁持有时间和冲突概率。
- **锁申请顺序**：调整申请锁的顺序，如先获取影响范围大的锁或固定访问数据的顺序，确保获取足够锁的同时避免死锁。
- **隔离级别调整**：用读已提交隔离级别替换可重复读，减少因间隙锁和临键锁导致的死锁情况。
- **索引优化**：合理建立索引，使操作能命中索引，减少加锁范围，降低死锁概率。
- **检测与等待时长设置**：开启死锁检测，并适当调整锁等待时长，以便及时发现和处理死锁情况。

### 手动关闭死锁步骤

手动 kill 语句步骤如下：

1. **查找当前的事务和锁信息**

- 执行 `SHOW ENGINE INNODB STATUS;` 命令，可输出 InnoDB 状态，从中找到被阻塞的事务及其线程 ID，同时也能查看死锁信息和当前的活动事务。
- 还可查询 INFORMATION_SCHEMA 中的 `INNODB_LOCKS` 和 `INNODB_LOCK_WAITS` 表来查看当前锁和锁等待情况以获取事务 ID。
- 通过查询 INFORMATION_SCHEMA 的 `innodb_trx` 表找到事务 ID 和线程 ID 的对应关系。

2. **手动终止该事务**：确定需要 KILL 的线程 ID 后，执行 `KILL <thread_id>;` 命令，将 `<thread_id>` 替换为实际找到的线程 ID。

同时对相关示例表的查询结果及字段解释如下：

- `INNODB_LOCKS`：

- 用于查询当前锁的信息。
- 示例结果中 `LOCK_ID` 唯一标识每个锁；`LOCK_MODE` 有排它锁（X）、共享锁（S）等类型；`LOCK_TYPE` 如 `RECORD` 表示行锁；`LOCK_TABLE` 是被锁定的表；`LOCK_INDEX` 为相关索引；`LOCK_OWNER` 是拥有该锁的事务 ID；`LOCK_DATA` 是被锁定的数据行的主键值。

- `INNODB_LOCK_WAITS`：

- 用于查询锁等待情况。
- 示例结果中 `REQUESTING_TRX_ID` 是请求锁的事务 ID；`HOLDING_TRX_ID` 是当前持有锁的事务 ID；`LOCK_ID` 与 `INNODB_LOCKS` 表中的锁相对应；`LOCK_TYPE` 是请求的锁类型。

- `INNODB_TRX`：

- 用于查询线程 ID 等信息。
- 示例结果中 `trx_state` 表示事务的当前状态，如 `LOCK_WAIT` 表示事务正在等待锁；`trx_started` 是事务开始的时间；`trx_mysql_thread_id` 与该事务关联的 MySQL 线程 ID，可用于查找事务更

